#!/usr/bin/env ruby
require 'optparse'

# TODO: Could be shell script so it runs just about anywhere?
class Vendor
  FILE  = %q{.gitvendor}
  USAGE = %q{
usage:
  git vendor <command>
  git vendor add <name> <url> [<path>]
  git vendor remove <name>
  git vendor update [<name>]

commands:
  add     Add a vendored git repository.
  remove  Remove a vendored git repository.
  update  Update vendored git repositories.
  }.strip

  def help options = {}
    puts USAGE
  end

=begin
  def install options = {}
    git_working_dir!
    # TODO: Install checkout hooks to auto-run vendor install when switching branches.
  end
=end

  def add url, path = nil, options = {}
    path, options = nil, path if path.kind_of?(Hash) # Ugh.
    url           = x!('git ls-remote --get-url %s', url)
    section       = options.fetch(:name, File.basename(url.sub(/[^:]*:/,''), '.git'))
    branch        = options.fetch(:branch, 'master')
    path          ||= File.join('vendor', section)

    git_working_dir!
    x!('git config -f %s vendor.%s.url %s',    FILE, section, url)
    x!('git config -f %s vendor.%s.path %s',   FILE, section, path)
    x!('git config -f %s vendor.%s.branch %s', FILE, section, branch)
    git_vendor(section, url, path, branch)
  end

  def remove name, options = {}
    git_working_dir!
    if vendor = git_config[name]
      path = vendor.fetch('path', File.join('vendor', name))
      if Dir.exists?(path)
        puts 'remove %s' % name
        x!('rm -rf %s', path)
        x!('git config -f %s --remove-section vendor.%s', FILE, name)
      end
    end
  end

  def update name, options = {}
    git_working_dir!
    git_config.each do |section, vendor|
      next if name && name != section
      url    = x!('git ls-remote --get-url %s', vendor.fetch('url'))
      path   = vendor.fetch('path', File.join('vendor', section))
      branch = vendor.fetch('branch', 'master')
      git_vendor(section, url, path, branch)
    end
  end

  private
    #--
    # TODO: escape args.
    def x! command, *args
      result = %x{#{command % args}}.strip
      $?.success? or exit(1)
      result
    end

    def git_vendor section, url, path, branch
      puts 'vendor %s' % section
      unless Dir.exists?(path)
        puts 'clone %s %s' % [url, path]
        x!('mkdir -p %s', path)
        x!('git clone -q --depth=1 %s %s', url, path) # TODO: suppress depth warning on local clones.
      end

      Dir.chdir(path) do
        x!('git reset --hard')
        x!('git clean -fXd')
        x!('git checkout -q %s', branch)
        x!('git pull')
      end

      # TODO: add path to a .gitignore in project if it isn't already.
    end

    def git_working_dir!
      # TODO: Check we aren't inside another git project. cd .. and git rev-parse --show-toplevel again.
      Dir.chdir(x!('git rev-parse --show-toplevel'))
    end

    #--
    # TODO: Validate path, url and ref exist for each vendor section.
    # TODO: Check for same config path with different URLs or ref.
    def git_config
      Dir["**/#{FILE}"].inject({}) do |sections, path|
        x!('git config -l -f %s', path).split.each do |line|
          fully_qualified_key, value      = line.split('=')
          vendor, section, key            = fully_qualified_key.split('.')
          (sections[section] ||= {})[key] = value if vendor == 'vendor'
        end
        sections
      end
    end
end

options = {}
OptionParser.new do |o|
  o.on('-h', '--help'){ options[:help] = true }
  o.on('-b', '--branch BRANCH'){|branch| options[:branch] = branch }
  o.on('-n', '--name NAME'){|name| options[:name] = name }
  o.parse!
end

vendor  = Vendor.new
command = (ARGV.shift || 'help').strip
case command
  when 'help'   then vendor.help(*ARGV, options)
  when 'add'    then vendor.add(ARGV.shift, *ARGV, options)
  when 'remove' then vendor.remove(ARGV[0], options)
  when 'update' then vendor.update(ARGV[0], options)
  else
    warn %q{unknown command '%s'} % command
    exit 1
end

